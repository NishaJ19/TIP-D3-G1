import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import joblib

class HybridMalwareDetector:
    def __init__(self):
        self.rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        self.knn_classifier = KNeighborsClassifier(n_neighbors=5)
        self.et_classifier = ExtraTreesClassifier(n_estimators=100, random_state=42)
        self.scaler = StandardScaler()
        self.label_encoder = LabelEncoder()
        self.feature_importance = None
        self.metrics = {}
        self.attack_cat_mapping = None

    def preprocess_data(self, df):
        """
        Preprocess the data by encoding categorical columns and scaling numerical values.
        """
        # Drop any irrelevant columns if necessary (e.g., 'id')
        if 'id' in df.columns:
            df = df.drop(['id'], axis=1)

        # Fill missing values if there are any
        df = df.fillna(0)

        # Identify categorical columns to encode
        categorical_columns = ['proto', 'service', 'state', 'attack_cat']
        
        # Encode categorical columns using Label Encoding
        for col in categorical_columns:
            if col in df.columns:
                # Convert categorical strings to numerical labels
                df[col] = self.label_encoder.fit_transform(df[col].astype(str))
                if col == 'attack_cat':
                    self.attack_cat_mapping = dict(enumerate(self.label_encoder.classes_))
        
        # Verify that all columns are numeric before returning the processed DataFrame
        return df

    def train(self, X, y):
        """
        Train the hybrid model using RandomForest, KNN, and ExtraTrees.
        """
        # Split the data into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

        # Scale features
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)

        # Train individual models
        self.rf_classifier.fit(X_train_scaled, y_train)
        self.knn_classifier.fit(X_train_scaled, y_train)
        self.et_classifier.fit(X_train_scaled, y_train)

        # Get feature importance from RandomForest
        self.feature_importance = pd.DataFrame({
            'feature': X.columns,
            'importance': self.rf_classifier.feature_importances_
        }).sort_values('importance', ascending=False)

        # Calculate metrics
        y_pred = self.predict(X_test)
        self.metrics = {
            'classification_report': classification_report(y_test, y_pred, output_dict=True),
            'confusion_matrix': confusion_matrix(y_test, y_pred).tolist(),
            'accuracy': accuracy_score(y_test, y_pred)
        }

        return self.metrics

    def predict(self, X):
        """
        Make predictions using the trained hybrid model.
        """
        # Scale features
        X_scaled = self.scaler.transform(X)

        # Get predictions from all models
        rf_pred = self.rf_classifier.predict_proba(X_scaled)
        knn_pred = self.knn_classifier.predict_proba(X_scaled)
        et_pred = self.et_classifier.predict_proba(X_scaled)

        # Ensemble predictions (weighted average)
        weighted_pred = (0.4 * rf_pred + 0.3 * knn_pred + 0.3 * et_pred)

        # Return the class with the highest probability
        return (weighted_pred[:, 1] >= 0.5).astype(int)

    def get_feature_importance(self):
        if self.feature_importance is None:
            raise ValueError("Feature importance is not calculated. Train the model first to obtain feature importance.")
        return self.feature_importance

    def get_metrics(self):
        if not self.metrics:
            raise ValueError("Metrics have not been calculated. Train the model first to obtain metrics.")
        return self.metrics

    def get_attack_cat_mapping(self):
        return self.attack_cat_mapping

    def save_model(self, path):
        # Save the entire model to a file
        joblib.dump(self, path)

    @staticmethod
    def load_model(path):
        # Load a saved model from a file
        return joblib.load(path)